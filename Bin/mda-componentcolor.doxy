// -*- Mode: c++ -*-

/** \addtogroup Programs
 ** \{
 **/

/**
   \page mda-componentcolor mda-componentcolor
   
   Convert between YCbCr component representation and RGB color
   spaces.
   
   The conversion formulas use parameters p0...p4 as follows
   
   \f[Y= p0\cdot R + p1\cdot G +p2\cdot B\f]
   \f[Cb= p3\cdot(B-Y)\f]
   \f[Cr= p4\cdot(R-Y)\f]
   
   In addition, different video standards convert the resulting
   floating point values to quantized representations, and may use
   only a subset of the numeric range to encode these values. For
   example 8 bit HDTV encodes Y in the range 16...235 and chroma in
   the range 16...240. Currently, all these parameters are not directly
   exposed; you have to select them through a pre-defined standard
   (see below).

   Be aware that the RGB color space differs depending on the video
   standard used. BT.709 uses the sRGB color space. BT.601 and JPEG
   use a different color space. Use an external color transform to map
   between these color spaces. Using dedicated RGB color spaces
   usually ensures that the results of a YCbCr to RGB conversion will
   be in the range [0...1].

   Note, however, that some video standards, such as xvYCC (a.k.a
   x.v.Color) allow for R,G,B values outside the range [0...1]. Choose
   a floating point format to capture that information without
   clamping.


   \param "--type <type>" output data type.

   \param --bt601 use ITU BT.601 (SD video) parameters.

   \param --bt709 use ITU BT.709 (HDTV video) parameters. Also use
   this option for xvYCC data.

   \param --jpeg use JPEG parameters.
   
   
   Example:
   
   \code
   mda-componentcolor --bt709 < yuv.mda > rgb.mda
   \endcode
   
   
   \todo expose all color space and quantization parameters to the
   command line
   
   \todo deal with >8bit quantizations
   
   \section complexity Arithmetic Complexity

   O(N), where N is the number of pixels in the array

   \section memory Memory Consumption

   O(N0), where N0 is the width of a scanline

   <hr>
*/

/** \} */
